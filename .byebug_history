node.nil? exit
child
prev_node
node
continue
node.nil?
child
node
prev_node
continue
child
node
prev_node
continue
child
prev_node
node
continue
node
prev_node
child
exit
continue
node
node.left_child
back
node = Node.new(0)
node.nil?
node
continue
node
continue
node
continue
node.left_child.left_child.left_child
node.left_child.left_child
node.right_child
node
exit
node.insert(0)
node
exit
continue
node.left_child.left_child.left_child.data
node
node.left_child.left_child.left_child
node.left_child.left_child.left_child = Node.new(0)
node.left_child.left_child.left_child
node.left_child.left_child
node.left_child
continue
node
node = Node.new(0)
node.nil?
node
continue
node.data
data < node.data
continue
data < node.data
node.data
node.left_child
node
continue
exit
continue
node
node.left_child = Node.new(2)
node
node.left_child = 3
node.left_child
node
node = Node.new(0)
node
continue
node.nil?
node
continue
data
node
continue
node
continue
node
exit
node.value
node.value == value
continue
node.value == value
node.value
value
node
exit
list.head
list.append('J')
list.head
exit
list.append('J')
list.head
exit
list.append('J')
list.head
list.append('Z')
list.head
continue
list.tail
list.head
list.append('Z')
list.head.append('Z')
list.head
list
exit
nodeexit
node
exit
head
self.head
node
exit
node
node.next_node.next_node
node.next_node.next_node.value
node.next_node.value
node
exit
node.value
continue
node.value
continue
node.value
continue
node.value
node
continue
node.value
node
continue
count
continue
exit
node.next_node.next_node
node.next_node.value
node.next_node
node.value
node
exit
node.next_node.next_node
node.next_node
node
node.tail
node.at(1)
node.value
exit
node
continue
node
continue
list.head.next.next
list.head.next..next
list.head.next.value
list.head.next_node
list.head.next
list.head.value
list.append('H')
list = LinkedList.new
exit
list.append('H')
list = LinkedList.new
exit
continue
node
value
continue
node
value
exit
arr[0, arr.length / 2 - 1]
exit
arr.slice(arr.length / 2)exit
arr.slice(arr.length / 2)
arr.slice(arr.length / 2 + 1)
arr.slice(arr.length / 2 + 1, arr.length)
arr.slice(arr.length / 2 + 1, arr.length - 1)
continue
arr.slice(arr.length/2+1, -1)
arr.slice(0, arr.length/2)
arr=
continue
contine
arr
continue
code
continue
green
continue
code
new_game.code
exit
continue
new_game.code
continue
new_grid.win_condition(player_1.mark)
continue
3
continue
exit
new_grid.win_condition(player_1.mark)
player_1
new_grid.win_condition(player_1)
continue
exit
new_grid.win_condition(player_1)
continue
5
continue
exit
new_grid.rows.values_at(*[1,5,9]).all?(player_1.mark) || new_grid.rows.values_at(*[1,4,7]).all?(player_1.mark) 
new_grid.win_condition(player_1)
new_grid
continue
new_grid.display
player_1
new_grid
new_grid.win_condition(player_1)
continue
exit
new_grid.rows.values_at(*[1,5,9]).all?(player_1.mark) || new_grid.rows.values_at(*[1,4,7]).all?(player_1.mark) 
new_grid.win_condition(player_1.mark)
new_grid.rows.values_at(*[1,5,9]).all?(player_1.mark)
new_grid.rows.values_at(*[1,5,9])
new_grid.rows.values_at(*[1])
new_grid.rows
new_grid.display
new_grid.win_condition(player_1.mark)
player_1.mark
self.rows.to_a.select { |r| grid << r[1] }
grid.any? { |block| block.empty?} grid = []
self.rows.to_a.select { |r| grid << r[1] }
grid = []
continue
exit
grid.any? { |block| block.empty?} 
grid
new_grid.rows.to_a.select { |r| grid << r[1] }
grid = []
grid.any? { |block| block.empty?} 
self.rows.to_a.select { |r| grid << r[1] }
grid = []
grid
new_grid.rows
new_grid.rows.to_a
new_grid.rows.to_a.select { |r| grid = r[1]}
grid = []
new_grid.rows.to_a
new_grid.rows
new_grid.moves_left?
